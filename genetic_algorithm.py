# -*- coding: utf-8 -*-
"""GA code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CIEAP63w7YABjU0UbX5Wu3DGOEeZ7NIX

# Fitness function
"""

import os
import sys
import numpy as np
from statistics import mode, mean, median, stdev, variance, quantiles
import math
from tqdm import tqdm
import itertools
from functools import reduce
import operator
import pacman
import layout
import pacman
import multiAgents
import ghostAgents
import textDisplay
from game import Directions

class GeneticAlgorithm:

    def __init__(self, 
                 n_genes,
                 n_iterations,
                 lchrom, 
                 pcross, 
                 pmutation, 
                 selection_type, 
                 popsize, 
                 n_elites,
                 data,
                 MAX_VALUE,
                 MIN_VALUE):
        

        self.n_genes = n_genes
        self.lchrom = lchrom
        self.popsize = popsize
        self.pcross = pcross
        self.pmutation = pmutation
        self.selection_type = selection_type
        self.n_iterations = n_iterations
        self.n_elites = n_elites
        self.data = data
        self.MAX_VALUE = MAX_VALUE
        self.MIN_VALUE = MIN_VALUE
        self.best_fitness_evolution = []
    
        pop = []
        while (len(pop) < self.popsize):
            # generate random chromosome a list of a random number between MIN_VALUE and MAX_VALUE where list length is n_genes
            chromosome = [np.random.randint(self.MIN_VALUE, self.MAX_VALUE) for _ in range(self.n_genes)]
            # if chromosome = set of 0 then generate new one
            if sum(chromosome) == 0:
                continue
            else:
                pop.append(chromosome)

        # Convert pop to list of solutions
        self.population = [tuple(x) for x in pop]
    


    def fitness_func(self, solution):
        # should maximize
        #  run pacman game with solution as weights
        def manhattanDistance(point1, point2):
            "Returns the Manhattan distance between points "
            return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])

        def customEvaluationFunction(currentGameState):

            def DClosestFood(current_pos, foodGrid, ghosts_pos):
                closestFood = 1
                food_distances = [manhattanDistance(current_pos, food) for food in foodGrid.asList()]
                
                if len(food_distances) > 0:
                    closestFood = min(food_distances)

                for ghost in ghosts_pos:
                    if manhattanDistance(current_pos, ghost) < 2:
                        closestFood = 99999
                return closestFood
                    
            current_pos = currentGameState.getPacmanPosition()
            ghosts_pos = currentGameState.getGhostPositions()

            foodGrid = currentGameState.getFood()
            capsuleList = currentGameState.getCapsules()

            numberOfFood = foodGrid.count()
            numberOfCapsules = len(capsuleList)

            features = [1.0 / DClosestFood(current_pos, foodGrid, ghosts_pos),
                        currentGameState.getScore(),
                        numberOfFood,
                        numberOfCapsules]

            score = 0
            for i in range(len(features)):
                score += features[i] * solution[i]
            return score

        # All MultiAgentSearchAgent have the same __init__ function 
        # thus we can generlize and pass the agent to the genetic algorithm using command line
        customAgent = self.data.agentToUse(actualEvalFunc=customEvaluationFunction, depth=2)
        baseGhosts =  [ghostAgents.DirectionalGhost(i+1) for i in range(self.data.numberOfGhosts)]
        game = self.data.rules.newGame(self.data.layout, customAgent, baseGhosts, self.data.gameDisplay)
        game.run() # simulate the game using a custom evaluation function given by the solution (weights)
        score = game.state.getScore()

        return score

    def get_fitness_scores(self):
        scores = [self.fitness_func(ind) for ind in self.population]
        return np.array(scores)

    def __append_best_score(self, scores):
        best_score = np.max(scores)
        self.best_fitness_evolution.append(best_score)
        return 'Ok'
    
    def __ranking_selection(self, scores):
        ind = np.argsort(scores)
        best_ind = ind[-1]
        return best_ind

    def select(self, scores, selection_type):
        if selection_type not in ['ranking', 'roulette']:
            raise ValueError('Type should be ranking or tournament')

        if selection_type == 'ranking':
            ind = self.__ranking_selection(scores)
        elif selection_type == 'roulette':
            ind = self.__roulette_selection(scores)
        else:
            pass
        return ind

    def flip(self, p):
        return 1 if np.random.rand() < p else 0

    def __crossover(self, 
                    parent1, 
                    parent2, 
                    pcross,
                    lchrom):
        index = np.random.choice(range(1, lchrom)) 
        parent1 = list(parent1)
        parent2 = list(parent2)
        child1 = parent1[:index] + parent2[index:]
        child2 = parent2[:index] + parent1[index:]
        children = [tuple(child1), tuple(child2)]
        return children
    
    def __mutation(self, individual):

        index = np.random.choice(len(individual))
        
        # Convert individual to list so that can be modified
        individual_mod = list(individual)
        individual_mod[index] = np.random.randint(self.MIN_VALUE, self.MAX_VALUE)
        individual = tuple(individual_mod)

        return individual

    def optimize(self):

        for i in tqdm(range(self.n_iterations)):

            # calculate fitness score
            scores = self.get_fitness_scores()

            # choose the elites of the current population
            ind = np.argsort(scores)

            elites = [self.population[i] for i in ind[-self.n_elites:]]

            print("Elites for iteration {} are {}".format(i, elites))
            #append the elites to the population
            new_population = [tuple(elite) for elite in elites]

            # make selection
            j = self.n_elites
            while j <= self.popsize:
                # select parents from population
                mate1 = self.select(scores, self.selection_type)
                mate2 = self.select(scores, self.selection_type)


                mate1 = tuple(self.population[mate1])
                mate2 = tuple(self.population[mate2])

                if self.flip(self.pcross):
                    children = self.__crossover(mate1, mate2, self.pcross, self.lchrom)
                    children = [tuple(child) for child in children]
                else:
                    children = [mate1, mate2]
                
                if self.flip(self.pmutation):
                    children[0] = self.__mutation(children[0])

                if self.flip(self.pmutation):
                    children[1] = self.__mutation(children[1])

                if sum(tuple(children[0])) != 0:
                    new_population.append(tuple(children[0]))
                    j+=1
                
                if sum(tuple(children[1])) != 0:
                    new_population.append(tuple(children[1]))        
                    j+=1

            self.population = new_population

        # when n_iterations are over, fitness scores
        scores = self.get_fitness_scores()

        # append best score
        _ = self.__append_best_score(scores)

        # get the result wher he results is the best
        best_score_ind =np.argpartition(scores, 0)[0]
    
        best_solution = self.population[best_score_ind]

        return (best_solution, self.best_fitness_evolution[-1])

def default(str):
    return str + ' [Default: %default]'

# A wrapper class just to hold data to be sent to the genetic algorithm
class Data:
    def __init__(self, layout, rules, gameDisplay, numberOfGhosts, agentToUse):
        self.layout = layout
        self.rules = rules
        self.gameDisplay = gameDisplay
        self.numberOfGhosts = numberOfGhosts
        self.agentToUse = agentToUse

def main( argv ):
    from optparse import OptionParser
    usageStr = """
    USAGE:      python genetic_algorithm.py <options>
    EXAMPLES:   (1) python genetic_algorithm.py -l smallClassic -k 10
                    - starts genetic algorithm on a small layout with 10 ghosts agents
    """
    parser = OptionParser(usageStr)
    parser.add_option('-k', '--numGhosts', dest='numGhosts', type='int',
                      help=default('the number of ghosts to run'), metavar='GHOSTS', default=10)
    parser.add_option('-l', '--layout', dest='layout',
                      help=default('the LAYOUT_FILE from which to load the map layout'),
                      metavar='LAYOUT_FILE', default='smallClassic')
    parser.add_option('-p', '--pacman', dest='pacman',
                        help=default('the agent TYPE in the pacmanAgents module to use'),
                        metavar='TYPE', default='AlphaBetaAgent')
    options, otherjunk = parser.parse_args(argv)
    if len(otherjunk) != 0:
        raise Exception('Command line input not understood: ' + str(otherjunk))
    
    used_layout = layout.getLayout(options.layout)
    k = options.numGhosts

    agentToUse = options.pacman

    if (agentToUse not in ["MinimaxAgent", "AlphaBetaAgent", "ExpectimaxAgent"]):
        raise Exception("Invalid agent to use")
    # get refrence to the class based on the string
    agentToUse = getattr(multiAgents, agentToUse)
    rules = pacman.ClassicGameRules()
    gameDisplay = textDisplay.NullGraphics()
    rules.quiet = True
    
    data = Data(used_layout, rules, gameDisplay, k, agentToUse)
    
    ga = GeneticAlgorithm(
        n_genes = 4,
        n_iterations = 20,
        lchrom = 4,
        pcross = 0.8, 
        pmutation = 0.35,
        selection_type = 'ranking', 
        popsize = 30,
        n_elites = 2,
        data = data,
        MAX_VALUE = 500,
        MIN_VALUE = -500,
    )

    best_solution, best_fitness = ga.optimize()
    print('\nBest solution:\t', best_solution)
    print('\nBest Fitness:\t', round(best_fitness))
    print("\n\n----------------------------------\n\n")

if __name__ == "__main__":
    main( sys.argv[1:] )
